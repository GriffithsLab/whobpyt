# -*- coding: utf-8 -*-
"""WWD_test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W-k8P5xZaopOKcoItFsYjOjsv5IIvo7-
"""
import matplotlib.pyplot as plt
import numpy as np
import time

class WWD_test():
    def __init__(self, G, gEE, gIE, gEI, Ws, step_size, node_size, Tr):
        self.G = G
        self.gEE = gEE
        self.gIE = gIE
        self.gEI = gEI
        L_s = -np.diag(np.sum(Ws, axis= 1)) + Ws
        self.L_s = L_s
        self.dt = step_size
        self.Tr = Tr
        self.node_size = node_size
        self.hidden_size = np.int64(Tr//step_size)
        X0 = np.random.uniform(0,1, (node_size,6))
        X0[:,3:] = 1.0 + X0[:,:3]
        self.X = X0

    def forward(self):
        """
        Forward step in generating the BOLD signal.
        """

        def smooth_normalize_ct(x, center):
            """
            Normalize the centers when smoothing
            """
            return center+ (center-0.001)*np.tanh((x-center)/(center - 0.001))

        def smooth_normalize(x):
            """
            Normalize small values to 0.000001.
            """
            x[x< 0.000001] = 0.000001
            return x

        def sigmoid(a, b, d, x):
            """
            Sigmoid function for linearizing the current.
            """
            return (a*x-b)/(1.0000-np.exp(-d*(a*x-b)))

        I0 = 0.2
        gamma = 0.641/1000.
        gammaI = 1.0/1000.

        aE = 310
        bE = 125
        dE_0 = 0.16
        WE = 1.0 #18.4576 #1.0

        aI = 615
        bI = 177
        dI_0 = 0.087
        WI = 0.7

        tauE = 100.
        tauI = 10.

        W1 = 0.02
        E = self.X[:,0]
        I = self.X[:,1]
        q = self.X[:,5]
        v = self.X[:,4]
        f = self.X[:,3]
        x = self.X[:,2]

        rho = 0.34
        tau_0 = 0.98
        alpha =0.32
        tau_s = 0.65
        tau_f = 0.41
        k = 1

        def fout(v, k):
            """
            Outflow using the Balloon Model
            """
            return (k*v)**(1.0/alpha)/k

        def Ef(f, k):
            """
            Energy function of the capillary bed
            """
            return 1.0 - (1.0 - rho)**(1.0/f/k)

        IE = np.tanh(smooth_normalize(WE*I0 + self.gEE*E + self.G*np.dot(self.L_s, E) -self.gIE*I))
        II = np.tanh(smooth_normalize(WI*I0 + self.gEI*E - I))

        # Calculate the differential values.
        dE =  E - self.dt*(E)/tauE \
                + self.dt*(1.0-E)*gamma*sigmoid(aE, bE, dE_0, IE)\
                + W1*np.sqrt(self.dt)*np.random.randn(self.node_size)
        dI = I - self.dt*I/tauI \
               + self.dt*gammaI*sigmoid(aI, bI, dI_0, II)+W1*np.sqrt(self.dt)*np.random.randn(self.node_size)
        dx = x + self.dt*(E\
               - 1.0/tau_s*x \
               - 1.0/tau_f *(k*f-1))
        f_tmp = f + self.dt*1/k*x
        dv = v + self.dt*(f/tau_0 - fout(v,k)/tau_0)
        dq = q + self.dt*(f*Ef(f,k)/rho/tau_0\
                  -q/v*fout(v,k)/tau_0)
        df = f_tmp
        x = np.tanh(dx) # smooth_normalize(dx, 0.5)
        v = 1.0 + np.tanh(dv - 1.0) # smooth_normalize_ct(dv, tf.constant(1., dtype=tf.float32), tf.constant(0., dtype=tf.float32), tf.constant(1.0, dtype=tf.float32))
        q = 1.0 + np.tanh(dq - 1.0) # smooth_normalize_ct(dq, tf.constant(1., dtype=tf.float32), tf.constant(0., dtype=tf.float32), tf.constant(1.0, dtype=tf.float32))
        f = 1.0 + np.tanh(f_tmp - 1.0)
        E = np.tanh(smooth_normalize(dE)) # 1.0 + np.tanh(dE - 1.0) #smooth_normalize_ct(dE, 1.0)#np.tanh(dE/200.0)
        I = np.tanh(smooth_normalize(dI)) # 1.0 + np.tanh(dI - 1.0)#smooth_normalize_ct(dI, 1.0)#np.tanh(dI/200.0)

        self.X = np.array([E, I, x, f, v, q]).T

    def output(self):
        """
        Output parameters when generating the BOLD signal.
        """
        W2 = 0.02
        E0 = 0.34
        rho = 0.34
        k1 = 7*E0
        k2 = 2.
        k3 = 2*E0-0.2
        V = 0.02
        k = 1
        q = self.X[:,4]
        v = self.X[:,5]

        y= k1*(1-k*q)+k2*(1-q/v)+k3*(1-k*v)

        return 100.0/E0*V*(y)+W2*np.random.randn(self.node_size)

    def generate_bold(self, num_tr):
        """
        Generate the BOLD signal using the hidden states and making steps forward.
        """
        bold =[]
        for j in range((20+ num_tr)*self.hidden_size):
            self.forward()
            if (j+1) % self.hidden_size == 0:
                bold.append(self.output())
        return np.array(bold[20:])

